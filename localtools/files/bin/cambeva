#!/usr/pkg/bin/perl
# $Id: cambeva,v 1.2 2006/11/10 11:40:59 abs Exp $

use strict;
use warnings;
use Image::Magick;
use Getopt::Std;

my %opt;
getopts( 'fs:nv', \%opt );
my $basedir = "$ENV{HOME}/sets";
my $prefix  = 'i_';

$ENV{PATH} =
'/usr/local/bin:/usr/bin:/bin:/usr/pkg/bin:/usr/games:/usr/sbin:/sbin:/usr/local/sbin:/usr/pkg/sbin:/usr/X11R6/bin:/bin';

umask(007);

if ( $opt{s} ) { $basedir = "$ENV{HOME}/$opt{s}"; }

safe_chdir($basedir);

if ( !@ARGV ) { usage(); }
if ( $ARGV[0] eq 'rotate-remote' ) {
    shift;
    foreach my $host (@ARGV) {
        $basedir = "$ENV{HOME}/sets.$host";
        safe_chdir($basedir);
        system("ssh $host cambeva remote-pull work-$$ | pax -r");
        rotate("work-$$");
    }
}
elsif ( $ARGV[0] eq 'start' )   { cambevao_start(); }
elsif ( $ARGV[0] eq 'stop' )    { cambevao_stop(); }
elsif ( $ARGV[0] eq 'restart' ) {
    cambevao_stop();
    cambevao_start();
}
elsif ( $ARGV[0] eq 'webcam' ) {
    cambevao_stop();
    cambevao_start(1);
}
elsif ( $ARGV[0] eq 'rotate' ) {
    shift;
    if (@ARGV) {
        foreach my $dir (@ARGV) { rotate($dir); }
    }
    else { rotate(); }
}
elsif ( $ARGV[0] eq 'remote-pull' && $ARGV[1] ) {
    rename( 'out', $ARGV[1] );
    mkdir( 'out', 0700 );
    system("pax -w $ARGV[1] && rm -rf $ARGV[1]");

    # XXX Not resiliant against disk errors on remote
    # Should include dirname to which to rotate, and second call to delete
}
else { usage(); }
exit;

sub cambevao_start {
    my ($webcam) = @_;

    my $conf_file = ".cambevao.xml";
    if ($webcam) { $webcam = 'true'; }
    else { $webcam = 'false'; }
    open( CONF, "+<$conf_file" ) || die("Unable to read $conf_file: $!");
    my @conf = grep( s/(httpserver\s+enabled=")\w+/$1$webcam/ || $_, <CONF> );
    seek( CONF, 0, 0 );
    print CONF @conf;
    close(CONF);

    $ENV{HOME} = $basedir;
    mkdir( 'out', 0700 );
    system('cambevao');
}

sub cambevao_stop { system('pkill cambevao'); }

sub run_cmd {
    print @_, "\n";
    system(@_);
}

sub generate_movie {
    my $movdir = 'wmv';
    my $movie  = "$movdir/$1-$2-$3-$4.wmv";
    mkdir( $movdir, 0700 );    # In case not present
    if ( !-f $movie ) {
        print "Encoding into $movie\n";
        system( "mencoder 'mf://$prefix*' -mf fps=25:type=jpeg "
              . "-ovc lavc -lavcopts vcodec=wmv2 -lavcopts vqscale=6:keyint=32 "
              . "-o $movie" );
    }
}

sub get_image {
    my ($file) = @_;
    my $image  = Image::Magick->new;
    my $err    = $image->Read($file);
    die "$file: $err" if "$err";
    $image->Crop( height => $image->Get('height') - 18 );

    # XXX should check size
    $image;
}

sub rotate {
    my ($dir) = @_;

    setpriority( 0, 0, 19 );
    if ( !$dir ) { $dir = 'out'; }
    opendir( DIR, $dir ) || die("opendir($dir) failed: $!");
    my @files = sort grep( /^$prefix/, readdir(DIR) );
    closedir(DIR);

    @files || return;
    print "Number of files in $dir: ", scalar(@files), "\n";

    my $last_image;
    my $last_dir;

    $last_dir = tag_filename( $dir, $files[0], '' );
    $last_dir =~ s#/.*##;    # Extract dir
    if ( opendir( DIR, $last_dir ) ) {
        my $last_file = ( sort grep( /^\d\d\d\d/, readdir(DIR) ) )[-1];
        closedir(DIR);       # XXX Should really find best, not last
        if ($last_file) {
            print "Last file: $last_dir/$last_file\n";
            $last_image = get_image("$last_dir/$last_file");
        }
    }

    my $tmpfile = "/tmp/descr.$$.txt";
    open( DESCR, "+>$tmpfile" ) || die("Unable to write $tmpfile: $!");
    unlink($tmpfile);
    foreach my $file (@files) {
        my $newfile;
        if ( -s "$dir/$file" == 0 ) {
            print "Delete empty $file";
            unlink("$dir/$file");
        }

        my $image = get_image("$dir/$file");
        if ($last_image) {
            $last_image->Composite( image => $image, compose => 'Difference' );
            $last_image->Describe( file => \*DESCR );
            seek( DESCR, 0, 0 );
            my %stats;
            while (<DESCR>) {
                if (/^\s*(Max|Mean|Standard deviation): (\S+)/) {
                    $stats{$1} += $2 / 3;
                }
            }
            seek( DESCR, 0, 0 );
            $newfile = tag_filename( $dir, $file,
                    int( $stats{Max} ) . '_'
                  . int( $stats{Mean} * 10 ) . '_'
                  . int( $stats{'Standard deviation'} * 10 ) );
        }
        else { $newfile = tag_filename( $dir, $file, 'sync' ); }
        if ( $newfile ne "$dir/$file" ) {
            if ( -f $newfile ) { die("$newfile already exists"); }
            verbose("Rename $dir/$file -> $newfile\n");
            unless ( $opt{n} ) {
                rename( "$dir/$file", $newfile ) || die("Rename failed: $!");
            }
        }
        $last_image = $image;
    }
    close(DESCR);
}

sub safe_chdir {
    my ($dir) = @_;
    chdir($dir) || die("Unable to chdir($dir): $!");
}

sub tag_filename {
    my ( $dir, $file, $tag ) = @_;
    if ( $file !~ /^($prefix)(\d{4})(\d\d)(\d\d)(\d{4})(\d\d)/ ) {
        die("Bad filename $file");
    }
    my $newdir = "$2-$3-$4";
    unless ( $opt{n} ) { mkdir( $newdir, 0700 ); }
    "$newdir/$5-$6.$tag.jpg";
}

sub usage {
    print "Usage: cambeva [start|stop|restart|rotate|rotate-remote|webcam]\n";
    exit;
}

sub verbose { $opt{v} && print @_; }

#	    composite -compose difference $LAST $FILE $TMPFILE
#	    diff=$(identify -verbose $TMPFILE | awk \
#		'BEGIN{d=0}/Standard deviation/{d += $3}END{printf "%03d",d}')
#	    NEWFILE=$(echo $FILE | sed "s/\.jpg/-$diff.jpg/")
#	    mv $FILE $NEWFILE
#	    FILE=$NEWFILE
#	fi

# awk '{metric=sqrt(($4*$4/$3/$3*$4*$2*$2*$3)/290);if(metric>10){print $1" "$2" "$3" "$4"    "int(metric)}}' < ../list | wc -l
